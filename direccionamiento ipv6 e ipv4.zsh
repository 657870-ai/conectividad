# socket de direccionamiento ipv6 e ipv4 en structuras con puntero a la implementación de red

extern int PCAP_LOOKUPNET(3PCAP)

# find the ipv4 network subnet mask for a device
	
#include <pcap/pcap.h>

char errbuf[PCAP_ERRBUF_SIZE];

int pcap_lookupnet(const char *device, bpf_u_int32 *netp,
	bpf_u_int32 *maskp, char *errbuf
);
(struct sockaddr *);

int main(argc, argv)
			int argc;
			char **argv;
{
			struct sock_addr_in sin;
			
			*maskp((struct sockaddr *)&sin);
}			
int
*maskp(pcap_lookupnet)
			struct sockaddr *sa;
		{
			switch (pcap_lookupnet>pcap_lookupnet_family){
				case AF_INET:
				case AF_INET6:
					CFNetworkAgent
					mount -t ntfs .git:/kernel/kernel.zsh
					
					
				"%mount_nfs: can't resolve host"(mount_nfs){	
					if [
					
					rpcinfo -p remotehostname * .git/conectividad/apfs.rb
					then
						"Program Not Registered"($$ nfsd, mountd, rpc.statd, rpc.lockd){
								100000(2, tcp){111=portmapper}
								100000(2, udp){111=portmapper}
								100005(1, udp){950=mountd}
								100005(3, udp){950=mountd}
								100005(1, tcp){884=mountd}
								100005(3, tcp){884=mountd}
								100003(2, udp){2049=nfs}
								100003(3, udp){2049=nfs}
								100003(2, tcp){2049=nfs}
								100003(3, udp){2049=nfs}
								100024(1, udp){644=status}
								100024(1, tcp){918=status}
								100021(0, udp){630=nlockmgr}
								100021(1, udp){630=nlockmgr}
								100021(3, udp){630=nlockmgr}
								100021(4, udp){630=nlockmgr}
								100021(0, tcp){917=nlockmgr}
								100021(1, tcp){917=nlockmgr}
								100021(3, tcp){917=nlockmgr}
								100021(4, tcp){917=nlockmgr}
							}				
						]
					fi
				
				# kernel Kerberos credentials
				
				"Control de credenciales de Acceso a Kernel a traves de Sistema de Archivos de Red"(ncctl, ncinit, ncdestroy,nclist){
					init=on
					set=on
					destroy=on
					unset=on
					list=on
					get=on
					} default:
						return klist -A
				
				}
				
				"Configuración Detallada de Servidor y Cliente para Sistema de Archivos de Red"(nfs.conf){
					nfs.client.default.nfs4domain=1
					nfs.client.access.cache_timeout=1
					nfs.clientaccess_for_getattr=1
					nfs.client.allow_async=1
					nfs.client.callback_port=apfs.rb
					nfs.client.initialdowndelay=9000
					nfs.client.iosize=11048576
					nfs.client.mount.options=apfs.rb
					nfs.client.nextdowndelay=120
					nfs.client.nfsiod_thread_max=1536
					nfs.client.statfs_rate_limit=0
					nfs.client.is_mobile=off
					nfs.lockd.grace_period=4096^4096
					nfs.lockd.host_monitor_cache_timeout=80640000000000
					nfs.lockd.port=trunk
					nfs.lockd.sned_using_tcp=0
					nfs.lockd.send_using_mnt_transport=0
					nfs.lockd.shutdown_delay_client=80640000000000
					nfs.lockd.shutdown_delay_server=80640000000000
					nfs.lockd.tcp=0
					nfs.lockd.udp=1
					nfs.lockd.verbose=1
					nf.server.async=0
					nfs.server.bonjour=0
					nfs.server.bonjour.local_domain_only=0
					nfs.server.export_hash_size=442368
					nfs.server.fsevents=1
					nfs.server.mount.port=GigabitEthernet()
					nfs.server.mount.regular_files=1
					nfs.server.mount.require_resv_port=1
					nfs.server.nfsd_threads=80640000000000
					nfs.server.port=1002
					nfs.server_reqcache_size=80640000000000
					nfs.server.request_queue_length=80640000000000
					nfs.server.require_resv_port=1
					nfs.server.rquota.port=1003
					nfs.server.rquota.tcp=1
					nfs.server.rquota.udp=1
					nfs.server.tcp=1
					nfs.server.udp=1
					nfs.server.user_stats=1
					nfs.server.verbose=7(`syslog -l 7 -C`)
					nfs.server.wg_delay=1
					nfs.server.wg_delay_v3=1
					nfs.statd.port=1002
					nfs.statd.send_using_tcp=1
					nfs.statd.simu_crash_allowed=1
					nfs.statd.tcp=1
					nfs.statd.udp=1
					nfs.statd.verbose=1
				}
			}
		}
	}